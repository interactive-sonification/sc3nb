:mod:`sc3nb`
============

.. py:module:: sc3nb

.. autoapi-nested-parse::

   Package for interfacing SuperCollider.

   Collection of Classes and functions for communicating
   with SuperCollider within python and jupyter notebooks,
   as well as playing recording and visualizing audio.












   .. rubric:: Examples

   For example usage please refer to the user guide.



   ..
       !! processed by numpydoc !!



Package Contents
----------------

 

Function List
~~~~~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   sc3nb.startup
   sc3nb.build_message
   sc3nb.linlin
   sc3nb.midicps
   sc3nb.cpsmidi
   sc3nb.clip
   sc3nb.dbamp
   sc3nb.ampdb




Class List
~~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   sc3nb.SC
   sc3nb.SCServer
   sc3nb.ServerOptions
   sc3nb.SCLang
   sc3nb.Node
   sc3nb.Synth
   sc3nb.Group
   sc3nb.AddAction
   sc3nb.SynthDef
   sc3nb.Buffer
   sc3nb.Bus
   sc3nb.Recorder
   sc3nb.TimedQueue
   sc3nb.TimedQueueSC
   sc3nb.Bundler



Content
~~~~~~~

.. function:: startup(start_server: bool = True, scsynth_path: Optional[str] = None, start_sclang: bool = True, sclang_path: Optional[str] = None, magic: bool = True, scsynth_options: Optional[ServerOptions] = None, with_blip: bool = True, console_logging: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS) -> SC

   Inits SuperCollider (scsynth, sclang) and registers Jupyter magics


   :Parameters:

       **start_server** : bool, optional
           If True boot scsynth, by default True

       **scsynth_path** : Optional[str], optional
           Path of scscynth executable, by default None

       **start_sclang** : bool, optional
           If True start sclang, by default True

       **sclang_path** : Optional[str], optional
           Path of sclang executable, by default None

       **magic** : bool, optional
           If True register magics to Jupyter, by default True

       **scsynth_options** : Optional[ServerOptions], optional
           Options for the server, by default None

       **with_blip** : bool, optional
           make a sound when booted, by default True

       **console_logging** : bool, optional
           If True write scsynth/sclang output to console, by default True

       **allowed_parents** : Sequence[str], optional
           Names of parents that are allowed for other instances of
           sclang/scsynth processes, by default ALLOWED_PARENTS

   :Returns:

       SC
           SuperCollider Interface class.













   ..
       !! processed by numpydoc !!


.. class:: SC(start_server: bool = True, scsynth_path: Optional[str] = None, start_sclang: bool = True, sclang_path: Optional[str] = None, scsynth_options: Optional[ServerOptions] = None, with_blib: bool = True, console_logging: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS)


   Create a SuperCollider Wrapper object.


   :Parameters:

       **start_server** : bool, optional
           If True boot scsynth, by default True.

       **scsynth_path** : Optional[str], optional
           Path of scscynth executable, by default None.

       **start_sclang** : bool, optional
           If True start sclang, by default True.

       **sclang_path** : Optional[str], optional
           Path of sclang executable, by default None.

       **scsynth_options** : Optional[ServerOptions], optional
           Options for the server, by default None.

       **with_blib** : bool, optional
           Make a sound when booted, by default True.

       **console_logging** : bool, optional
           If True write scsynth/sclang output to console, by default True.

       **allowed_parents** : Sequence[str], optional
           Names of parents that are allowed for other instances of
           sclang/scsynth processes, by default ALLOWED_PARENTS.














   ..
       !! processed by numpydoc !!



   .. attribute:: default
      :annotation: :Optional['SC']

      Default SC instance.

      This will be used by all SuperCollider objects if no SC/server/lang is specified.















      ..
          !! processed by numpydoc !!




   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.SC.get_default
         sc3nb.SC.start_sclang
         sc3nb.SC.start_server
         sc3nb.SC.server
         sc3nb.SC.lang
         sc3nb.SC.console_logging
         sc3nb.SC.__del__
         sc3nb.SC.exit

   .. method:: get_default(cls) -> sc3nb.sc.SC
      :classmethod:

      Get the default SC instance



      :Returns:

          SC
              default SC instance




      :Raises:

          RuntimeError
              If there is no default SC instance.









      ..
          !! processed by numpydoc !!


   .. method:: start_sclang(self, sclang_path: Optional[str] = None, console_logging: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS)

      Start this SuperCollider language


      :Parameters:

          **sclang_path** : Optional[str], optional
              Path of sclang executable, by default None

          **console_logging** : bool, optional
              If True write scsynth/sclang output to console, by default True

          **allowed_parents** : Sequence[str], optional
              Names of parents that are allowed for other instances of
              sclang/scsynth processes, by default ALLOWED_PARENTS














      ..
          !! processed by numpydoc !!


   .. method:: start_server(self, scsynth_options: Optional[ServerOptions] = None, scsynth_path: Optional[str] = None, console_logging: bool = True, with_blip: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS)

      Start this SuperCollider server


      :Parameters:

          **scsynth_options** : Optional[ServerOptions], optional
              Options for the server, by default None

          **scsynth_path** : Optional[str], optional
              Path of scscynth executable, by default None

          **console_logging** : bool, optional
              If True write scsynth/sclang output to console, by default True

          **with_blip** : bool, optional
              make a sound when booted, by default True

          **allowed_parents** : Sequence[str], optional
              Names of parents that are allowed for other instances of
              sclang/scsynth processes, by default ALLOWED_PARENTS














      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> sc3nb.sc_objects.server.SCServer
      :property:

      This SuperCollider server object
















      ..
          !! processed by numpydoc !!


   .. method:: lang(self) -> sc3nb.sclang.SCLang
      :property:

      This SuperCollider language object
















      ..
          !! processed by numpydoc !!


   .. method:: console_logging(self)
      :property:

      True if console logging enabled
















      ..
          !! processed by numpydoc !!


   .. method:: __del__(self)


   .. method:: exit(self) -> None

      Closes SuperCollider and shuts down server
















      ..
          !! processed by numpydoc !!





.. class:: SCServer(options: Optional[ServerOptions] = None)


   **Bases:** :class:`sc3nb.osc.osc_communication.OSCCommunication`

   SuperCollider audio server representaion.


   :Parameters:

       **options** : Optional[ServerOptions], optional
           Options used to start the local server, by default None














   ..
       !! processed by numpydoc !!

   Create a OSC communication server


   :Parameters:

       **server_ip** : str
           IP address to use for this server

       **server_port** : int
           port to use for this server

       **default_receiver_ip** : str
           IP address used for sending by default

       **default_receiver_port** : int
           port used for sending by default














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.SCServer.boot
         sc3nb.SCServer.init
         sc3nb.SCServer.execute_init_hooks
         sc3nb.SCServer.add_init_hook
         sc3nb.SCServer.bundler
         sc3nb.SCServer.blip
         sc3nb.SCServer.remote
         sc3nb.SCServer.reboot
         sc3nb.SCServer.ping
         sc3nb.SCServer.quit
         sc3nb.SCServer.sync
         sc3nb.SCServer.send_synthdef
         sc3nb.SCServer.load_synthdef
         sc3nb.SCServer.load_synthdefs
         sc3nb.SCServer.notify
         sc3nb.SCServer._get_errors_for_address
         sc3nb.SCServer.free_all
         sc3nb.SCServer.send_default_groups
         sc3nb.SCServer.allocate_node_id
         sc3nb.SCServer.allocate_buffer_id
         sc3nb.SCServer.allocate_control_bus_idx
         sc3nb.SCServer.allocate_audio_bus_idx
         sc3nb.SCServer.client_id
         sc3nb.SCServer.max_logins
         sc3nb.SCServer.default_group
         sc3nb.SCServer.input_bus
         sc3nb.SCServer.output_bus
         sc3nb.SCServer.volume
         sc3nb.SCServer.muted
         sc3nb.SCServer.mute
         sc3nb.SCServer.unmute
         sc3nb.SCServer.version
         sc3nb.SCServer.status
         sc3nb.SCServer.dump_osc
         sc3nb.SCServer.dump_tree
         sc3nb.SCServer.query_all_nodes
         sc3nb.SCServer.peak_cpu
         sc3nb.SCServer.avg_cpu
         sc3nb.SCServer.sample_rate
         sc3nb.SCServer.actual_sample_rate
         sc3nb.SCServer.num_synths
         sc3nb.SCServer.num_groups
         sc3nb.SCServer.num_ugens
         sc3nb.SCServer.num_synthdefs
         sc3nb.SCServer.addr
         sc3nb.SCServer.has_booted
         sc3nb.SCServer.is_running
         sc3nb.SCServer.unresponsive
         sc3nb.SCServer.is_local
         sc3nb.SCServer.pid
         sc3nb.SCServer._log_message
         sc3nb.SCServer._warn_fail

   .. method:: boot(self, scsynth_path: Optional[str] = None, timeout: float = 3, console_logging: bool = True, with_blip: bool = True, kill_others: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS)

      Start the Server process.


      :Parameters:

          **scsynth_path** : str, optional
              Path of scscynth executable, by default None

          **timeout** : float, optional
              Timeout for starting the executable, by default 3

          **console_logging** : bool, optional
              If True write process output to console, by default True

          **with_blip** : bool, optional
              make a sound when booted, by default True

          **kill_others** : bool
              kill other SuperCollider server processes.

          **allowed_parents** : Sequence[str], optional
              Names of parents that are allowed for other instances of
              sclang/scsynth processes that won't be killed, by default ALLOWED_PARENTS





      :Raises:

          ValueError
              If UDP port specified in options is already used

          ProcessTimeout
              If the process fails to start.









      ..
          !! processed by numpydoc !!


   .. method:: init(self, with_blip: bool = True)

      Initialize the server.

      This adds allocators, loads SynthDefs, send default Groups etc.

      :Parameters:

          **with_blip** : bool, optional
              make a sound when initialized, by default True














      ..
          !! processed by numpydoc !!


   .. method:: execute_init_hooks(self) -> None

      Run all init hook functions.
















      ..
          !! processed by numpydoc !!


   .. method:: add_init_hook(self, function: Callable[(..., None)], args: Optional[Sequence[Any]] = None) -> None

      Add a function to be executed when the server is initialized


      :Parameters:

          **function** : Callable[..., None]
              Function to be executed

          **args** : Optional[Sequence[Any]], optional
              Arguments given to function, by default None














      ..
          !! processed by numpydoc !!


   .. method:: bundler(self, timestamp=0, msg=None, msg_args=None, send_on_exit=True)

      Generate a Bundler with added server latency.

      This allows the user to easly add messages/bundles and send it.

      :Parameters:

          **timestamp** : int
              Time at which bundle content should be executed.
              This servers latency will be added upon this.
              If timestamp <= 1e6 it is added to time.time().

          **msg_addr** : str
              SuperCollider address.

          **msg_args** : list, optional
              List of arguments to add to message.
               (Default value = None)

      :Returns:

          Bundler
              bundler for OSC bundling.













      ..
          !! processed by numpydoc !!


   .. method:: blip(self) -> None

      Make a blip sound
















      ..
          !! processed by numpydoc !!


   .. method:: remote(self, address: str, port: int, with_blip: bool = True) -> None

      Connect to remote Server


      :Parameters:

          **address** : str
              address of remote server

          **port** : int
              port of remote server

          **with_blip** : bool, optional
              make a sound when initialized, by default True














      ..
          !! processed by numpydoc !!


   .. method:: reboot(self) -> None

      Reboot this server







      :Raises:

          RuntimeError
              If this server is remote and can't be restarted.









      ..
          !! processed by numpydoc !!


   .. method:: ping(self)
      :abstractmethod:

      Ping the server.
















      ..
          !! processed by numpydoc !!


   .. method:: quit(self) -> None

      Quits and tries to kill the server.
















      ..
          !! processed by numpydoc !!


   .. method:: sync(self, timeout=5) -> bool

      Sync the server with the /sync command.


      :Parameters:

          **timeout** : int, optional
              Time in seconds that will be waited for sync.
               (Default value = 5)

      :Returns:

          bool
              True if sync worked.













      ..
          !! processed by numpydoc !!


   .. method:: send_synthdef(self, synthdef_bytes: bytes, wait: bool = True)

      Send a SynthDef as bytes.


      :Parameters:

          **synthdef_bytes** : bytes
              SynthDef bytes

          **wait** : bool
              If True wait for server reply.














      ..
          !! processed by numpydoc !!


   .. method:: load_synthdef(self, synthdef_path: str, wait: bool = True)

      Load SynthDef file at path.


      :Parameters:

          **synthdef_path** : str
              Path with the SynthDefs

          **wait** : bool
              If True wait for server reply.














      ..
          !! processed by numpydoc !!


   .. method:: load_synthdefs(self, synthdef_dir: Optional[str] = None, completion_msg: bytes = None, wait: bool = True) -> None

      Load all SynthDefs from directory.


      :Parameters:

          **synthdef_dir** : str, optional
              directory with SynthDefs, by default sc3nb default SynthDefs

          **completion_msg** : bytes, optional
              Message to be executed by the server when loaded, by default None

          **wait** : bool, optional
              If True wait for server reply, by default True














      ..
          !! processed by numpydoc !!


   .. method:: notify(self, receive_notifications: bool = True, client_id: Optional[int] = None, timeout: float = 1.0) -> None

      Notify the server about this client.

      This provides the client id and max logins info needed for default groups.

      :Parameters:

          **receive_notifications** : bool, optional
              Flag for receiving node notification from server, by default True

          **client_id** : int, optional
              Propose a client id, by default None

          **timeout** : float, optional
              Timeout for server reply, by default 1.0





      :Raises:

          RuntimeError
              If server has too many users.

          OSCCommunicationError
              If OSC communication fails.









      ..
          !! processed by numpydoc !!


   .. method:: _get_errors_for_address(self, address: str)


   .. method:: free_all(self, root: bool = True) -> None

      Free all node ids.


      :Parameters:

          **root** : bool, optional
              If False free only the default group of this client, by default True














      ..
          !! processed by numpydoc !!


   .. method:: send_default_groups(self) -> None

      Send the default groups for all clients.
















      ..
          !! processed by numpydoc !!


   .. method:: allocate_node_id(self) -> int

      Get a node id.



      :Returns:

          int
              node id













      ..
          !! processed by numpydoc !!


   .. method:: allocate_buffer_id(self, num: int = 1) -> Sequence[int]

      Get the next free buffer id.



      :Returns:

          int
              buffer id













      ..
          !! processed by numpydoc !!


   .. method:: allocate_control_bus_idx(self, num: int = 1) -> Sequence[int]

      Get the next free bus id.



      :Returns:

          int
              bus id













      ..
          !! processed by numpydoc !!


   .. method:: allocate_audio_bus_idx(self, num: int = 1) -> Sequence[int]

      Get the next free bus id.



      :Returns:

          int
              bus id













      ..
          !! processed by numpydoc !!


   .. method:: client_id(self)
      :property:

      The client id for this server
















      ..
          !! processed by numpydoc !!


   .. method:: max_logins(self)
      :property:

      Maximum number of possible logins at server
















      ..
          !! processed by numpydoc !!


   .. method:: default_group(self)
      :property:

      This clients default group
















      ..
          !! processed by numpydoc !!


   .. method:: input_bus(self) -> sc3nb.sc_objects.bus.Bus
      :property:

      This servers input Bus
















      ..
          !! processed by numpydoc !!


   .. method:: output_bus(self) -> sc3nb.sc_objects.bus.Bus
      :property:

      This servers output Bus
















      ..
          !! processed by numpydoc !!


   .. method:: volume(self) -> float
      :property:

      Volume in dB.
















      ..
          !! processed by numpydoc !!


   .. method:: muted(self) -> bool
      :property:

      True if audio is muted
















      ..
          !! processed by numpydoc !!


   .. method:: mute(self) -> None

      Mute audio
















      ..
          !! processed by numpydoc !!


   .. method:: unmute(self) -> None

      Set volume back to volume prior to muting
















      ..
          !! processed by numpydoc !!


   .. method:: version(self) -> sc3nb.sc_objects.server.ServerVersion

      Server version information
















      ..
          !! processed by numpydoc !!


   .. method:: status(self) -> sc3nb.sc_objects.server.ServerStatus

      Server status information
















      ..
          !! processed by numpydoc !!


   .. method:: dump_osc(self, level: int = 1) -> None

      Enable dumping incoming OSC messages at the server process


      :Parameters:

          **level** : int, optional
              Verbosity code, by default 1
              0   turn dumping OFF.
              1   print the parsed contents of the message.
              2   print the contents in hexadecimal.
              3   print both the parsed and hexadecimal representations.














      ..
          !! processed by numpydoc !!


   .. method:: dump_tree(self, controls: bool = True, return_tree=False) -> Optional[str]

      Server process prints out current nodes


      :Parameters:

          **controls** : bool, optional
              If True include control values, by default True

          **return_tree** : bool, optional
              If True return output as string, by default False

      :Returns:

          str
              If return_tree this is the node tree string.













      ..
          !! processed by numpydoc !!


   .. method:: query_all_nodes(self, include_controls: bool = True) -> sc3nb.sc_objects.node.Group

      Query all nodes at the server and return a NodeTree


      :Parameters:

          **include_controls** : bool, optional
              If True include control values, by default True

      :Returns:

          NodeTree
              object containing all the nodes.













      ..
          !! processed by numpydoc !!


   .. method:: peak_cpu(self) -> float
      :property:

      Peak cpu usage of server process
















      ..
          !! processed by numpydoc !!


   .. method:: avg_cpu(self) -> float
      :property:

      Average cpu usage of server process
















      ..
          !! processed by numpydoc !!


   .. method:: sample_rate(self) -> float
      :property:

      Nominal sample rate of server process
















      ..
          !! processed by numpydoc !!


   .. method:: actual_sample_rate(self) -> float
      :property:

      Actual sample rate of server process
















      ..
          !! processed by numpydoc !!


   .. method:: num_synths(self) -> int
      :property:

      Number of Synths in server tree
















      ..
          !! processed by numpydoc !!


   .. method:: num_groups(self) -> int
      :property:

      Number of Groups in server tree
















      ..
          !! processed by numpydoc !!


   .. method:: num_ugens(self) -> int
      :property:

      Number of UGens in server tree
















      ..
          !! processed by numpydoc !!


   .. method:: num_synthdefs(self) -> int
      :property:

      Number of SynthDefs known by server
















      ..
          !! processed by numpydoc !!


   .. method:: addr(self) -> Tuple[(str, int)]
      :property:

      Address (ip, port) of server
















      ..
          !! processed by numpydoc !!


   .. method:: has_booted(self) -> bool
      :property:

      If the server is booted
















      ..
          !! processed by numpydoc !!


   .. method:: is_running(self) -> bool
      :property:

      If the server is running
















      ..
          !! processed by numpydoc !!


   .. method:: unresponsive(self) -> bool
      :property:

      If the server process is unresponsive
















      ..
          !! processed by numpydoc !!


   .. method:: is_local(self) -> bool
      :property:

      If the server process is local
















      ..
          !! processed by numpydoc !!


   .. method:: pid(self)
      :property:

      The process id of the local server process
















      ..
          !! processed by numpydoc !!


   .. method:: _log_message(self, sender, *args)


   .. method:: _warn_fail(self, sender, *args)





.. class:: ServerOptions(udp_port: int = SCSYNTH_DEFAULT_PORT, max_logins: int = 6, num_input_buses: int = 2, num_output_buses: int = 2, num_audio_buses: int = 1024, num_control_buses: int = 4096, num_sample_buffers: int = 1024, publish_rendezvous: bool = False, block_size: Optional[int] = None, hardware_buffer_size: Optional[int] = None, hardware_sample_size: Optional[int] = None, hardware_input_device: Optional[str] = None, hardware_output_device: Optional[str] = None, other_options: Optional[Sequence[str]] = None)


   Options for the SuperCollider audio server

   This allows the encapsulation and handling of the command line server options.















   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.ServerOptions.first_private_bus
         sc3nb.ServerOptions.num_private_buses
         sc3nb.ServerOptions.__repr__

   .. method:: first_private_bus(self) -> int
      :property:

      The first audio bus after input and output buses
















      ..
          !! processed by numpydoc !!


   .. method:: num_private_buses(self) -> int
      :property:

      Number of audio buses besides input and output buses
















      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self)

      Return repr(self).
















      ..
          !! processed by numpydoc !!





.. class:: SCLang


   Class to control the SuperCollider Language Interpreter (sclang).
















   ..
       !! processed by numpydoc !!

   Creates a python representation of sclang.







   :Raises:

       NotImplementedError
           When an unsupported OS was found.









   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.SCLang.start
         sc3nb.SCLang.load_synthdefs
         sc3nb.SCLang.kill
         sc3nb.SCLang.__del__
         sc3nb.SCLang.cmd
         sc3nb.SCLang.cmdv
         sc3nb.SCLang.cmds
         sc3nb.SCLang.cmdg
         sc3nb.SCLang.read
         sc3nb.SCLang.empty
         sc3nb.SCLang.get_synth_desc
         sc3nb.SCLang.addr
         sc3nb.SCLang.server
         sc3nb.SCLang.connect_to_server

   .. method:: start(self, sclang_path: Optional[str] = None, console_logging: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS) -> None

      Start and initilize the sclang process.

      This will also kill sclang processes that does not have allowed parents.

      :Parameters:

          **sclang_path** : Optional[str], optional
              Path with the sclang executable, by default None

          **console_logging** : bool, optional
              If True log sclang output to console, by default True

          **allowed_parents** : Sequence[str], optional
              parents name of processes to keep, by default ALLOWED_PARENTS





      :Raises:

          SCLangError
              When starting or initilizing sclang failed.









      ..
          !! processed by numpydoc !!


   .. method:: load_synthdefs(self, synthdefs_path: Optional[str] = None) -> None

      Load SynthDef files from path.


      :Parameters:

          **synthdefs_path** : str, optional
              Path where the SynthDef files are located.
              If no path provided, load default sc3nb SynthDefs.














      ..
          !! processed by numpydoc !!


   .. method:: kill(self) -> int

      Kill this sclang instance.



      :Returns:

          int
              returncode of the process.













      ..
          !! processed by numpydoc !!


   .. method:: __del__(self)


   .. method:: cmd(self, code: str, pyvars: Optional[dict] = None, verbose: bool = True, discard_output: bool = True, get_result: bool = False, print_error: bool = True, get_output: bool = False, timeout: int = 1) -> Any

      Send code to sclang to execute it.

      This also allows to get the result of the code or the corresponding output.

      :Parameters:

          **code** : str
              SuperCollider code to execute.

          **pyvars** : dict, optional
              Dictionary of name and value pairs of python
              variables that can be injected via ^name, by default None

          **verbose** : bool, optional
              If True print output, by default True

          **discard_output** : bool, optional
              If True clear output buffer before passing command, by default True

          **get_result** : bool, optional
              If True receive and return the
              evaluation result from sclang, by default False

          **print_error** : bool, optional
              If this and get_result is True and code execution fails
              the output from sclang will be printed.

          **get_output** : bool, optional
              If True return output. Does not override get_result
              If verbose this will be True, by default False

          **timeout** : int, optional
              Timeout for code execution return result, by default 1

      :Returns:

          Any
              if get_result=True,
                  Result from SuperCollider code,
                  not all SC types supported.
                  When type is not understood this
                  will return the datagram from the
                  OSC packet.
              if get_output or verbose
                  Output from SuperCollider code.
              else
                  None




      :Raises:

          RuntimeError
              If get_result is True but no OSCCommunication instance is set.

          SCLangError
              When an error with sclang occurs.









      ..
          !! processed by numpydoc !!


   .. method:: cmdv(self, code: str, **kwargs) -> Any

      cmd with verbose=True
















      ..
          !! processed by numpydoc !!


   .. method:: cmds(self, code: str, **kwargs) -> Any

      cmd with verbose=False, i.e. silent
















      ..
          !! processed by numpydoc !!


   .. method:: cmdg(self, code: str, **kwargs) -> Any

      cmd with get_result=True
















      ..
          !! processed by numpydoc !!


   .. method:: read(self, expect: Optional[str] = None, timeout: float = 1, print_error: bool = True) -> str

      Reads SuperCollider output from the process output queue.


      :Parameters:

          **expect** : Optional[str], optional
              Try to read this expected string, by default None

          **timeout** : int, optional
              How long we try to read expected string, by default 1

          **print_error** : bool, optional
              If True this will print a message when timed out, by default True

      :Returns:

          str
              output from sclang process.




      :Raises:

          timeout
              If expected output string could not be read before timeout.









      ..
          !! processed by numpydoc !!


   .. method:: empty(self) -> None

      Empties sc output queue.
















      ..
          !! processed by numpydoc !!


   .. method:: get_synth_desc(self, synth_def)

      Get SynthDesc via sclangs global SynthDescLib.


      :Parameters:

          **synth_def** : str
              SynthDef name

      :Returns:

          dict
              {argument_name: SynthArgument(rate, default)}




      :Raises:

          ValueError
              When synthDesc of synthDef can not be found.









      ..
          !! processed by numpydoc !!


   .. method:: addr(self) -> Tuple[(str, int)]
      :property:

      The address of this sclang
















      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> Optional[SCServer]
      :property:

      The SuperCollider server connected to this sclang instance.
















      ..
          !! processed by numpydoc !!


   .. method:: connect_to_server(self, server: Optional[SCServer] = None)

      Connect this sclang instance to the SuperCollider Server.

      This will set Server.default and s to a the provided remote Server.

      :Parameters:

          **server** : Optional[SCServer], optional
              SuperCollider Server to connect. If None try to reconnect.





      :Raises:

          ValueError
              If something different from a SCServer or None was provided

          SCLangError
              If sclang failed to register to the server.









      ..
          !! processed by numpydoc !!





.. class:: Node(*, nodeid: Optional[int] = None, add_action: Optional[Union[AddAction, int]] = None, target: Optional[Union['Node', int]] = None, server: Optional['SCServer'] = None)


   **Bases:** :class:`abc.ABC`

   Representation of a Node on SuperCollider.
















   ..
       !! processed by numpydoc !!

   Create a new Node


   :Parameters:

       **nodeid** : int or None
           This Nodes node id or None

       **add_action** : AddAction or corresponding int, optional
           This Nodes AddAction when created in Server, by default None

       **target** : Node or int or None, optional
           This Nodes AddActions target, by default None

       **server** : SCServer, optional
           The Server for this node, by default server














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Node.new
         sc3nb.Node._get_status_repr
         sc3nb.Node._set_node_attrs
         sc3nb.Node.nodeid
         sc3nb.Node.group
         sc3nb.Node.server
         sc3nb.Node.is_playing
         sc3nb.Node.is_running
         sc3nb.Node.freed
         sc3nb.Node.started
         sc3nb.Node.free
         sc3nb.Node.run
         sc3nb.Node.set
         sc3nb.Node._update_control
         sc3nb.Node._update_controls
         sc3nb.Node.fill
         sc3nb.Node.map
         sc3nb.Node.release
         sc3nb.Node.query
         sc3nb.Node.trace
         sc3nb.Node.move
         sc3nb.Node.register
         sc3nb.Node.unregister
         sc3nb.Node.on_free
         sc3nb.Node.wait
         sc3nb.Node._parse_info
         sc3nb.Node._handle_notification
         sc3nb.Node.__eq__
         sc3nb.Node._get_nodeid

   .. method:: new(self, *args, add_action: Optional[Union[AddAction, int]] = None, target: Optional[Union['Node', int]] = None, return_msg: bool = False, **kwargs) -> Union[('Node', OscMessage)]
      :abstractmethod:

      Create a new Node


      :Parameters:

          **add_action** : AddAction or int, optional
              Where the Node should be added, by default AddAction.TO_HEAD (0)

          **target** : Node or int, optional
              AddAction target, if None it will be the default group of the server














      ..
          !! processed by numpydoc !!


   .. method:: _get_status_repr(self) -> str


   .. method:: _set_node_attrs(self, target: Optional[Union['Node', int]] = None, add_action: Optional[Union[AddAction, int]] = None) -> None

      Derive Node group from addaction and target


      :Parameters:

          **target** : int or Node
              Target nodeid or Target Node of this Node's AddAction

          **add_action** : AddAction
              AddAction of this Node, default AddAction.TO_HEAD (0)














      ..
          !! processed by numpydoc !!


   .. method:: nodeid(self) -> int
      :property:

      Identifier of node.
















      ..
          !! processed by numpydoc !!


   .. method:: group(self) -> Optional[int]
      :property:

      Identifier of this nodes group.
















      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> sc3nb.sc_objects.server.SCServer
      :property:

      The server on which this node is located.
















      ..
          !! processed by numpydoc !!


   .. method:: is_playing(self) -> Optional[bool]
      :property:

      True if this node is playing. None if unkown.
















      ..
          !! processed by numpydoc !!


   .. method:: is_running(self) -> Optional[bool]
      :property:

      True if this node is running. None if unkown.
















      ..
          !! processed by numpydoc !!


   .. method:: freed(self) -> bool
      :property:

      True if free was called on this node.

      This is reseted when receiving a /n_go notification















      ..
          !! processed by numpydoc !!


   .. method:: started(self) -> bool
      :property:

      True if new was called on this node.

      This is reseted when receiving a /n_end notification















      ..
          !! processed by numpydoc !!


   .. method:: free(self, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Free the node with /n_free.

      This will set is_running and is_playing to false.
      Even when the message is returned to mimic the behavior of the SuperCollider Node
      See https://doc.sccode.org/Classes/Node.html#-freeMsg


      :Returns:

          OscMessage or Node
              self for chaining or OscMessage when return_msg=True













      ..
          !! processed by numpydoc !!


   .. method:: run(self, flag: bool = True, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Turn node on or off with /n_run.



      :Returns:

          OscMessage or Node
              self for chaining or OscMessage when return_msg=True













      ..
          !! processed by numpydoc !!


   .. method:: set(self, argument: Union[(str, Dict, List)], *values: Any, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Set a control value(s) of the node with n_set.


      :Parameters:

          **argument** : str | dict | list
              if string: name of control argument
              if dict: dict with argument, value pairs
              if list: use list as message content

          **value** : any, optional
              only used if argument is string, by default None











      .. rubric:: Examples

      >>> synth.set("freq", 400)
      >>> synth.set({"dur": 1, "freq": 400})
      >>> synth.set(["dur", 1, "freq", 400])



      ..
          !! processed by numpydoc !!


   .. method:: _update_control(self, control: str, value: Any) -> None


   .. method:: _update_controls(self, controls: Optional[Dict[str, Any]] = None) -> None


   .. method:: fill(self, control: Union[(str, int)], num_controls: int, value: Any, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Fill ranges of control values with n_fill.


      :Parameters:

          **control** : int or string
              control index or name

          **num_controls** : int
              number of control values to fill

          **value** : float or int
              value to set

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: map(self, control: Union[(str, int)], bus: sc3nb.sc_objects.bus.Bus, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Map a node's control to read from a bus using /n_map or /n_mapa.


      :Parameters:

          **control** : int or string
              control index or name

          **bus** : Bus
              control/audio bus

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: release(self, release_time: Optional[float] = None, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Set gate as specified.

      https://doc.sccode.org/Classes/Node.html#-release

      :Parameters:

          **release_time** : float, optional
              amount of time in seconds during which the node will release.
              If set to a value <= 0, the synth will release immediately.
              If None using its Envs normal release stage(s)

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: query(self) -> Union[(SynthInfo, GroupInfo)]

      Sends an n_query message to the server.

      The answer is send to all clients who have registered via the /notify command.
      Content of answer:

      node ID
      the node's parent group ID
      previous node ID, -1 if no previous node.
      next node ID, -1 if no next node.
      1 if the node is a group, 0 if it is a synth

      if the node is a group:
          ID of the head node, -1 if there is no head node.
          ID of the tail node, -1 if there is no tail node.


      :Returns:

          SynthInfo or GroupInfo
              n_info answer. See above for content description













      ..
          !! processed by numpydoc !!


   .. method:: trace(self, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Trace a node.

      Print out values of the inputs and outputs for one control period.
      If node is a group then print the node IDs and names of each node.

      :Parameters:

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage or Node
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: move(self, add_action: sc3nb.sc_objects.node.AddAction, another_node: sc3nb.sc_objects.node.Node, return_msg: bool = False) -> Union[(OscMessage, 'Node')]

      Move this node


      :Parameters:

          **add_action** : AddAction [TO_HEAD, TO_TAIL, AFTER, BEFORE]
              What add action should be done.

          **another_node** : Node
              The node which is the target of the add action

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage or Node
              if return_msg this will be the OscMessage, else self




      :Raises:

          ValueError
              If a wrong AddAction was provided









      ..
          !! processed by numpydoc !!


   .. method:: register(self)
      :abstractmethod:

      Register to be watched.
















      ..
          !! processed by numpydoc !!


   .. method:: unregister(self)
      :abstractmethod:

      Unregister to stop being watched.
















      ..
          !! processed by numpydoc !!


   .. method:: on_free(self, func)
      :abstractmethod:

      Callback that is executed when this Synth is freed
















      ..
          !! processed by numpydoc !!


   .. method:: wait(self, timeout: Optional[float] = None)

      Wait until this Node is freed
















      ..
          !! processed by numpydoc !!


   .. method:: _parse_info(self, nodeid: int, group: int, prev_nodeid: int, next_nodeid: int, *rest: Sequence[int]) -> Union[(SynthInfo, GroupInfo)]


   .. method:: _handle_notification(self, kind: str, info) -> None


   .. method:: __eq__(self, other)

      Return self==value.
















      ..
          !! processed by numpydoc !!


   .. method:: _get_nodeid(value: Union[('Node', int)]) -> int
      :staticmethod:

      Get the corresponding node id


      :Parameters:

          **value** : Node or int
              If a Node is provided it will get its nodeid
              If a int is provided it will be returned

      :Returns:

          int
              nodeid




      :Raises:

          ValueError
              When neither Node or int was provided









      ..
          !! processed by numpydoc !!





.. class:: Synth(name: Optional[str] = None, controls: Dict[(str, Any)] = None, *, nodeid: Optional[int] = None, new: bool = True, add_action: Optional[Union[AddAction, int]] = None, target: Optional[Union['Node', int]] = None, server: Optional['SCServer'] = None)


   **Bases:** :class:`sc3nb.sc_objects.node.Node`

   Representation of a Synth on SuperCollider.
















   ..
       !! processed by numpydoc !!

   Create a Python representation of a SuperCollider synth.


   :Parameters:

       **sc** : SC
           sc3nb SuperCollider instance

       **name** : str, optional
           name of the synth to be created, by default "default"

       **controls** : dict, optional
           synth control arguments, by default None

       **nodeid** : int, optional
           ID of the node in SuperCollider, by default sc will create one

       **new** : bool, optional
           True if synth should be created on the server, by default True

       **add_action** : AddAction or int, optional
           Where the Synth should be added, by default AddAction.TO_HEAD (0)

       **target** : Node or int, optional
           AddAction target, if None it will be the default group of the server





   :Raises:

       ValueError
           Raised when synth can't be found via SynthDescLib.global






   .. rubric:: Examples

   >>> scn.Synth(sc, "s1", {"dur": 1, "freq": 400})



   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Synth._update_synth_state
         sc3nb.Synth.synth_desc
         sc3nb.Synth.name
         sc3nb.Synth.current_controls
         sc3nb.Synth.new
         sc3nb.Synth.get
         sc3nb.Synth.seti
         sc3nb.Synth.__getattr__
         sc3nb.Synth.__setattr__
         sc3nb.Synth.__repr__

   .. method:: _update_synth_state(self, name: Optional[str], controls: Optional[dict])


   .. method:: synth_desc(self) -> Optional[Dict[str, 'SynthArgument']]
      :property:

      This Synths SynthDef name.
















      ..
          !! processed by numpydoc !!


   .. method:: name(self) -> str
      :property:

      This Synths SynthDef name.
















      ..
          !! processed by numpydoc !!


   .. method:: current_controls(self) -> Dict[(str, Any)]
      :property:

      This Synth currently cached control arguments.
















      ..
          !! processed by numpydoc !!


   .. method:: new(self, controls: Optional[dict] = None, add_action: Optional[Union[AddAction, int]] = None, target: Optional[Union[Node, int]] = None, *, return_msg: bool = False) -> Union[('Synth', OscMessage)]

      Creates the synth on the server with s_new.

      Attention: Here you create an identical synth! Same nodeID etc.
      - This will fail if there is already this nodeID on the SuperCollider server!















      ..
          !! processed by numpydoc !!


   .. method:: get(self, control: str) -> Any

      Get a Synth argument

      This will request the value from scsynth with /s_get(n).

      :Parameters:

          **control** : str
              name of the Synth control argument














      ..
          !! processed by numpydoc !!


   .. method:: seti(self, *args)
      :abstractmethod:

      Set part of an arrayed control.
















      ..
          !! processed by numpydoc !!


   .. method:: __getattr__(self, name)


   .. method:: __setattr__(self, name, value)

      Implement setattr(self, name, value).
















      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!





.. class:: Group(*, nodeid: Optional[int] = None, new: bool = True, parallel: bool = False, add_action: sc3nb.sc_objects.node.AddAction = AddAction.TO_HEAD, target: Optional[Union[Node, int]] = None, server: Optional['SCServer'] = None)


   **Bases:** :class:`sc3nb.sc_objects.node.Node`

   Representation of a Group on SuperCollider.
















   ..
       !! processed by numpydoc !!

   Create a Python representation of a SuperCollider group.


   :Parameters:

       **nodeid** : int, optional
           ID of the node in SuperCollider, by default sc will create one

       **new** : bool, optional
           True if synth should be created on the server, by default True

       **parallel** : bool, optional
           If True create a parallel group, by default False

       **add_action** : AddAction or int, optional
           Where the Group should be added, by default AddAction.TO_HEAD (0)

       **target** : Node or int, optional
           AddAction target, if None it will be the default group of the server

       **server** : SCServer, optional
           Server instance where this Group is located, by default the default Server














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Group._update_group_state
         sc3nb.Group.new
         sc3nb.Group.children
         sc3nb.Group.move_node_to_head
         sc3nb.Group.move_node_to_tail
         sc3nb.Group.free_all
         sc3nb.Group.deep_free
         sc3nb.Group.dump_tree
         sc3nb.Group.query_tree
         sc3nb.Group._repr_pretty_
         sc3nb.Group.__repr__

   .. method:: _update_group_state(self, children: Optional[Sequence[Node]] = None) -> None


   .. method:: new(self, add_action=AddAction.TO_HEAD, target=None, *, parallel=None, return_msg=False) -> Union[('Group', OscMessage)]

      Creates the synth on the server with g_new / p_new.

      Attention: Here you create an identical group! Same nodeID etc.
      - This will fail if there is already this nodeID on the SuperCollider server!

      :Parameters:

          **add_action** : AddAction or int, optional
              where the group should be added, by default AddAction.TO_HEAD (0)

          **target** : Node or int, optional
              add action target, by default 1

          **parallel** : bool, optional
              If True use p_new, by default False

          **return_msg** : bool, optional
              If ture return the OscMessage instead of sending it, by default False

      :Returns:

          Group
              self













      ..
          !! processed by numpydoc !!


   .. method:: children(self) -> Sequence[Node]
      :property:

      Return this groups children as currently known



      :Returns:

          Sequence[Node]
              Sequence of child Nodes (Synths or Groups)













      ..
          !! processed by numpydoc !!


   .. method:: move_node_to_head(self, node)

      Move node to this groups head with g_head.


      :Parameters:

          **node** : Node
              node to move

      :Returns:

          Group
              self













      ..
          !! processed by numpydoc !!


   .. method:: move_node_to_tail(self, node)

      Move node to this groups tail with g_tail.


      :Parameters:

          **node** : Node
              node to move

      :Returns:

          Group
              self













      ..
          !! processed by numpydoc !!


   .. method:: free_all(self, return_msg=False)

      Frees all nodes in the group with g_freeAll.


      :Parameters:

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: deep_free(self, return_msg=False)

      Free all synths in this group and its sub-groups with g_deepFree.

      Sub-groups are not freed.

      :Parameters:

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: dump_tree(self, post_controls=True, return_msg=False)

      Posts a representation of this group's node subtree with g_dumpTree.


      :Parameters:

          **post_controls** : bool, optional
              True for control values, by default False

          **return_msg** : bool, optional
              If True return msg else send it directly, by default False

      :Returns:

          OscMessage
              if return_msg else self













      ..
          !! processed by numpydoc !!


   .. method:: query_tree(self, include_controls=False) -> sc3nb.sc_objects.node.Group

      Send a g_queryTree message for this group.

      See https://doc.sccode.org/Reference/Server-Command-Reference.html#/g_queryTree for details.

      :Parameters:

          **include_controls** : bool, optional
              True for control values, by default False

      :Returns:

          tuple
              /g_queryTree.reply













      ..
          !! processed by numpydoc !!


   .. method:: _repr_pretty_(self, p, cylce)


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!





.. class:: AddAction

   **Bases:** :class:`enum.Enum`

   AddAction of SuperCollider nodes.

   This Enum contains the codes for the different ways to add a node.















   ..
       !! processed by numpydoc !!



   .. attribute:: TO_HEAD
      :annotation: = 0

      

   .. attribute:: TO_TAIL
      :annotation: = 1

      

   .. attribute:: BEFORE
      :annotation: = 2

      

   .. attribute:: AFTER
      :annotation: = 3

      

   .. attribute:: REPLACE
      :annotation: = 4

      






.. class:: SynthDef(name: str, definition: str, sc: Optional['SC'] = None)


   Wrapper for SuperCollider SynthDef
















   ..
       !! processed by numpydoc !!

   Create a dynamic synth definition in sc.


   :Parameters:

       **name** : string
           default name of the synthdef creation.
           The naming convention will be name+int, where int is the amount of
           already created synths of this definition

       **definition** : string
           Pass the default synthdef definition here. Flexible content
           should be in double brackets ("...{{flexibleContent}}...").
           This flexible content, you can dynamic replace with set_context()

       **sc** : SC object
           SC instance where the synthdef should be created














   ..
       !! processed by numpydoc !!



   .. attribute:: synth_descs
      

      



   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.SynthDef.get_description
         sc3nb.SynthDef.send
         sc3nb.SynthDef.load
         sc3nb.SynthDef.load_dir
         sc3nb.SynthDef.reset
         sc3nb.SynthDef.set_context
         sc3nb.SynthDef.set_contexts
         sc3nb.SynthDef.unset_remaining
         sc3nb.SynthDef.add
         sc3nb.SynthDef.free
         sc3nb.SynthDef.__repr__

   .. method:: get_description(cls, name: str) -> Optional[Dict[str, 'SynthArgument']]
      :classmethod:

      Get Synth description


      :Parameters:

          **name** : str
              name of SynthDef

      :Returns:

          Dict
              dict with SynthArguments













      ..
          !! processed by numpydoc !!


   .. method:: send(cls, synthdef_bytes: bytes, wait: bool = True, server: Optional['SCServer'] = None)
      :classmethod:

      Send a SynthDef as bytes.


      :Parameters:

          **synthdef_bytes** : bytes
              SynthDef bytes

          **wait** : bool
              If True wait for server reply.

          **server** : SCServer, optional
              Server that gets the SynthDefs, by default None














      ..
          !! processed by numpydoc !!


   .. method:: load(cls, synthdef_path: str, wait: bool = True, server: Optional['SCServer'] = None)
      :classmethod:

      Load SynthDef file at path.


      :Parameters:

          **synthdef_path** : str
              Path with the SynthDefs

          **wait** : bool
              If True wait for server reply.

          **server** : SCServer, optional
              Server that gets the SynthDefs, by default None














      ..
          !! processed by numpydoc !!


   .. method:: load_dir(cls, synthdef_dir: Optional[str] = None, completion_msg: Optional[bytes] = None, wait: bool = True, server: Optional['SCServer'] = None)
      :classmethod:

      Load all SynthDefs from directory.


      :Parameters:

          **synthdef_dir** : str, optional
              directory with SynthDefs, by default sc3nb default SynthDefs

          **completion_msg** : bytes, optional
              Message to be executed by the server when loaded, by default None

          **wait** : bool, optional
              If True wait for server reply, by default True

          **server** : SCServer, optional
              Server that gets the SynthDefs, by default None














      ..
          !! processed by numpydoc !!


   .. method:: reset(self) -> sc3nb.sc_objects.synthdef.SynthDef

      Reset the current synthdef configuration to the self.definition value.

      After this you can restart your
      configuration with the same root definition


      :Returns:

          object of type SynthDef
              the SynthDef object













      ..
          !! processed by numpydoc !!


   .. method:: set_context(self, searchpattern: str, value) -> sc3nb.sc_objects.synthdef.SynthDef

      Set context in SynthDef.

      This method will replace a given key (format: "...{{key}}...") in the
      synthdef definition with the given value.

      :Parameters:

          **searchpattern** : string
              search pattern in the current_def string

          **value** : string or something with can parsed to string
              Replacement of search pattern

      :Returns:

          **self** : object of type SynthDef
              the SynthDef object













      ..
          !! processed by numpydoc !!


   .. method:: set_contexts(self, dictionary: Dict[(str, Any)]) -> sc3nb.sc_objects.synthdef.SynthDef

      Set multiple values at onces when you give a dictionary.

      Because dictionaries are unsorted, keep in mind, that
      the order is sometimes ignored in this method.

      :Parameters:

          **dictionary** : dict
              {searchpattern: replacement}

      :Returns:

          **self** : object of type SynthDef
              the SynthDef object













      ..
          !! processed by numpydoc !!


   .. method:: unset_remaining(self) -> sc3nb.sc_objects.synthdef.SynthDef

      This method will remove all existing placeholders in the current def.

      You can use this at the end of definition
      to make sure, that your definition is clean. Hint: This method will
      not remove pyvars


      :Returns:

          **self** : object of type SynthDef
              the SynthDef object













      ..
          !! processed by numpydoc !!


   .. method:: add(self, pyvars=None, name: Optional[str] = None, server: Optional['SCServer'] = None) -> str

      This method will add the current_def to SuperCollider.s

      If a synth with the same definition was already in sc, this method
      will only return the name.

      :Parameters:

          **pyvars** : dict
              SC pyvars dict, to inject python variables

          **name** : str, optional
              name which this SynthDef will get

          **server** : SCServer, optional
              server where this SynthDef will be send to

      :Returns:

          str
              Name of the SynthDef













      ..
          !! processed by numpydoc !!


   .. method:: free(self) -> sc3nb.sc_objects.synthdef.SynthDef

      Free this SynthDef from the server.



      :Returns:

          **self** : object of type SynthDef
              the SynthDef object













      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self)

      Return repr(self).
















      ..
          !! processed by numpydoc !!





.. class:: Buffer(bufnum: Optional[int] = None, server: Optional['SCServer'] = None)


   A Buffer object represents a SuperCollider3 Buffer on scsynth
   and provides access to low-level buffer commands of scsynth via
   methods of the Buffer objects.

   The constructor merely initializes a buffer:

   * it selects a buffer number using the server's buffer allocator
   * it initializes attribute variables

   :Parameters:

       **bufnum** : int
           buffer number to be used on scsynth. Defaults to None
           can be set to enforce a given bufnum

       **server** : SCServer, optional
           The server instance to establish the Buffer









   .. rubric:: Notes

   For more information on Buffer commands, refer to the Server Command Reference in SC3.
   https://doc.sccode.org/Reference/Server-Command-Reference.html#Buffer%20Commands


   .. rubric:: Examples

   (see examples/buffer-examples.ipynb)

   >>> b = Buffer().load_file(...)
   >>> b = Buffer().load_data(...)
   >>> b = Buffer().alloc(...)
   >>> b = Buffer().load_asig(...)
   >>> b = Buffer().use_existing(...)
   >>> b = Buffer().copy(Buffer)

   :Attributes:

       **server** : the SCServer object
           to communicate with scsynth

       **_bufnum** : int
           buffer number = bufnum id on scsynth

       **_sr** : int
           the sampling rate of the buffer

       **_channels** : int
           number of channels of the buffer

       **_samples** : int
           buffer length = number of sample frames

       **_alloc_mode** : str
           ['file', 'alloc', 'data', 'existing', 'copy']
           according to previously used generator, defaults to None

       **_allocated** : boolean
           True if Buffer has been allocated by
           any of the initialization methods

       **_path** : str
           path to the audio file used in load_file()


   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Buffer.read
         sc3nb.Buffer.alloc
         sc3nb.Buffer.load_data
         sc3nb.Buffer.load_collection
         sc3nb.Buffer.load_asig
         sc3nb.Buffer.use_existing
         sc3nb.Buffer.copy_existing
         sc3nb.Buffer.fill
         sc3nb.Buffer.gen
         sc3nb.Buffer.zero
         sc3nb.Buffer.gen_sine1
         sc3nb.Buffer.gen_sine2
         sc3nb.Buffer.gen_sine3
         sc3nb.Buffer.gen_cheby
         sc3nb.Buffer.gen_copy
         sc3nb.Buffer.play
         sc3nb.Buffer.write
         sc3nb.Buffer.close
         sc3nb.Buffer.to_array
         sc3nb.Buffer.query
         sc3nb.Buffer._repr_pretty_
         sc3nb.Buffer.free
         sc3nb.Buffer.bufnum
         sc3nb.Buffer.allocated
         sc3nb.Buffer.alloc_mode
         sc3nb.Buffer.path
         sc3nb.Buffer.channels
         sc3nb.Buffer.samples
         sc3nb.Buffer.sr
         sc3nb.Buffer.duration
         sc3nb.Buffer.server
         sc3nb.Buffer._gen_flags

   .. method:: read(self, path: str, starting_frame: int = 0, num_frames: int = -1, channels: Optional[Union[int, Sequence[int]]] = None) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer space and read a sound file.

      If the number of frames argument is less than or equal to zero,
      the entire file is read.

      :Parameters:

          **path** : string
              path name of a sound file.

          **starting_frame** : int
              starting frame in file

          **num_frames** : int
              number of frames to read

          **channels** : list | int
              channels and order of channels to be read from file.
              if only a int is provided it is loaded as only channel

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: alloc(self, size: int, sr: float = 44100, channels: int = 1) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer space.


      :Parameters:

          **size** : int
              number of frames

          **sr** : int
              sampling rate in Hz (optional. default = 44100)

          **channels** : int
              number of channels (optional. default = 1 channel)

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: load_data(self, data: numpy.ndarray, mode: str = 'file', sr: float = 44100) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer space and read input data.


      :Parameters:

          **data** : numpy array
              Data which should inserted

          **mode** : 'file' or 'osc'
              Insert data via filemode ('file') or n_set OSC commands ('osc')

          **sr** : int=44100
              sample rate

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: load_collection(self, data: numpy.ndarray, mode: str = 'file', sr: float = 44100) -> sc3nb.sc_objects.buffer.Buffer

      Wrapper method of :func:`Buffer.load_data`
















      ..
          !! processed by numpydoc !!


   .. method:: load_asig(self, asig: pya.Asig, mode: str = 'file') -> sc3nb.sc_objects.buffer.Buffer

      Create buffer from asig


      :Parameters:

          **asig** : pya.Asig
              asig to be loaded in buffer

          **mode** : str, optional
              Insert data via filemode ('file') or n_set OSC commands ('osc'), by default 'file'

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: use_existing(self, bufnum: int, sr: float = 44100) -> sc3nb.sc_objects.buffer.Buffer

      Creates a buffer object from already existing Buffer bufnum.


      :Parameters:

          **bufnum** : int
              buffer node id

          **sr** : int
              Sample rate

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: copy_existing(self, buffer: sc3nb.sc_objects.buffer.Buffer) -> sc3nb.sc_objects.buffer.Buffer

      Duplicate an existing buffer


      :Parameters:

          **buffer** : Buffer object
              Buffer which should be duplicated

      :Returns:

          **self** : Buffer
              the newly created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: fill(self, start: int = 0, count: int = 0, value: float = 0) -> sc3nb.sc_objects.buffer.Buffer

      Fill range of samples with value(s).


      :Parameters:

          **start** : int or list
              int : sample starting index
              list : n*[start, count, value] list

          **count** : int
              number of samples to fill

          **value** : float
              value

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen(self, command: str, args: List[Any]) -> sc3nb.sc_objects.buffer.Buffer

      Call a command to fill a buffer.
      If you know, what you do -> you can use this method.


      :Parameters:

          **command** : str
              What fill command to use.

          **args** : List[Any]
              Arguments for command

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.



      .. seealso::

          
          :obj:`gen_sine1`, :obj:`gen_sine2`, :obj:`gen_cheby`, :obj:`gen_cheby`, :obj:`gen_copy`
              ..
          





      ..
          !! processed by numpydoc !!


   .. method:: zero(self) -> sc3nb.sc_objects.buffer.Buffer

      Set buffer data to zero.



      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine1(self, amplitudes: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves & given amplitude


      :Parameters:

          **amplitudes** : list
              The first float value specifies the amplitude of the first partial,
              the second float value specifies the amplitude of the second
              partial, and so on.

          **normalize** : bool
              Normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, then the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set then the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine2(self, freq_amps: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves
      given list of [frequency, amplitude] lists


      :Parameters:

          **freq_amps** : list
              Similar to sine1 except that each partial frequency is specified
              explicitly instead of being an integer multiple of the fundamental.
              Non-integer partial frequencies are possible.

          **normalize** : bool
              If set, normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set, the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine3(self, freqs_amps_phases: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves & given a list of
      [frequency, amplitude, phase] entries.


      :Parameters:

          **freqs_amps_phases** : list
              Similar to sine2 except that each partial may have a
              nonzero starting phase.

          **normalize** : bool
              if set, normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format
              so that it can be read by interpolating oscillators.

          **clear** : bool
              If set, the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_cheby(self, amplitudes: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fills a buffer with a series of chebyshev polynomials, which can be
      defined as cheby(n) = amplitude * cos(n * acos(x))


      :Parameters:

          **amplitudes** : list
              The first float value specifies the amplitude for n = 1,
              the second float value specifies the amplitude
              for n = 2, and so on

          **normalize** : bool
              If set, normalize the peak amplitude of the Buffer to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_copy(self, source: sc3nb.sc_objects.buffer.Buffer, source_pos: int, dest_pos: int, copy_amount: int) -> sc3nb.sc_objects.buffer.Buffer

      Copy samples from the source buffer to the destination buffer
      specified in the b_gen command.


      :Parameters:

          **source** : Buffer
              Source buffer object

          **source_pos** : int
              sample position in source

          **dest_pos** : int
              sample position in destination

          **copy_amount** : int
              number of samples to copy. If the number of samples to copy is
              negative, the maximum number of samples
              possible is copied.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: play(self, rate: float = 1, loop: bool = False, pan: float = 0, amp: float = 0.3) -> sc3nb.sc_objects.node.Synth

      Play the Buffer using a Synth


      :Parameters:

          **rate** : float, optional
              plackback rate, by default 1

          **loop** : bool, optional
              if True loop the playback, by default False

          **pan** : int, optional
              pan position, -1 is left, +1 is right, by default 0

          **amp** : float, optional
              amplitude, by default 0.3

      :Returns:

          Synth
              Synth to control playback.




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: write(self, path: str, header: str = 'wav', sample: str = 'float', num_frames: int = -1, starting_frame: int = 0, leave_open: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Write buffer data to a sound file


      :Parameters:

          **path** : string
              path name of a sound file.

          **header** : string
              header format. Header format is one of:
              "aiff", "next", "wav", "ircam"", "raw"

          **sample** : string
              sample format. Sample format is one of:
              "int8", "int16", "int24", "int32",
              "float", "double", "mulaw", "alaw"

          **num_frames** : int
              number of frames to write.
              -1 means all frames.

          **starting_frame** : int
              starting frame in buffer

          **leave_open** : boolean
              Whether you want the buffer file left open.
              For use with DiskOut you will want this to be true.
              The file is created, but no frames are written until the DiskOut ugen does so.
              The default is false which is the correct value for all other cases.

      :Returns:

          **self** : Buffer
              the Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: close(self) -> sc3nb.sc_objects.buffer.Buffer

      Close soundfile after using a Buffer with DiskOut



      :Returns:

          **self** : Buffer
              the Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: to_array(self) -> numpy.ndarray

      Return the buffer data as an array representation.



      :Returns:

          np.ndarray:
              Values of the buffer




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: query(self) -> sc3nb.sc_objects.buffer.BufferInfo

      Get buffer info.



      :Returns:

          Tuple:
              (buffernumber, number of frames, number of channels, sample rate)




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: _repr_pretty_(self, p, cycle) -> None


   .. method:: free(self) -> None

      Free buffer data.







      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: bufnum(self) -> Optional[int]
      :property:

      Buffer number which serves as ID in SuperCollider



      :Returns:

          int
              bufnum













      ..
          !! processed by numpydoc !!


   .. method:: allocated(self) -> bool
      :property:

      Whether this Buffer is allocated by
      any of the initialization methods.



      :Returns:

          bool
              True if allocated













      ..
          !! processed by numpydoc !!


   .. method:: alloc_mode(self) -> sc3nb.sc_objects.buffer.BufferAllocationMode
      :property:

      Mode of Buffer allocation.

      One of ['file', 'alloc', 'data', 'existing', 'copy']
      according to previously used generator.
      Defaults to None if not allocated.


      :Returns:

          str
              allocation mode













      ..
          !! processed by numpydoc !!


   .. method:: path(self) -> Optional[Path]
      :property:

      File path that was provided to read.



      :Returns:

          pathlib.Path
              buffer file path













      ..
          !! processed by numpydoc !!


   .. method:: channels(self) -> Optional[int]
      :property:

      Number of channels in the Buffer.



      :Returns:

          int
              channel number













      ..
          !! processed by numpydoc !!


   .. method:: samples(self) -> Optional[int]
      :property:

      Number of samples in the buffer.



      :Returns:

          int
              sample number













      ..
          !! processed by numpydoc !!


   .. method:: sr(self) -> Optional[float]
      :property:

      Sampling rate of the Buffer.



      :Returns:

          float
              sampling rate













      ..
          !! processed by numpydoc !!


   .. method:: duration(self) -> Optional[float]
      :property:

      Duration of the Buffer in seconds.



      :Returns:

          float
              duration in seconds













      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> sc3nb.sc_objects.server.SCServer
      :property:

      The server where this Buffer is placed.



      :Returns:

          SCServer
              The server where this Buffer is placed.













      ..
          !! processed by numpydoc !!


   .. method:: _gen_flags(self, a_normalize=False, a_wavetable=False, a_clear=False) -> int

      Generate Wave Fill Commands flags from booleans
      according to the SuperCollider Server Command Reference.


      :Parameters:

          **a_normalize** : bool, optional
              Normalize peak amplitude of wave to 1.0, by default False

          **a_wavetable** : bool, optional
              If set, then the buffer is written in wavetable
              format so that it can be read by interpolating
              oscillators, by default False

          **a_clear** : bool, optional
              If set then the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer, by default False

      :Returns:

          int
              Wave Fill Commands flags













      ..
          !! processed by numpydoc !!





.. class:: Bus(rate: Union[(BusRate, str)], num_channels: int = 1, index: Optional[int] = None, server: Optional['SCServer'] = None)


   Represenation of a Control or Audio Bus on the SuperCollider Server
















   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Bus.rate
         sc3nb.Bus.num_channels
         sc3nb.Bus.idxs
         sc3nb.Bus.is_audio_bus
         sc3nb.Bus.is_control_bus
         sc3nb.Bus.set
         sc3nb.Bus.fill
         sc3nb.Bus.get
         sc3nb.Bus.free
         sc3nb.Bus.__del__
         sc3nb.Bus.__repr__

   .. method:: rate(self) -> Union[(BusRate, str)]
      :property:

      The bus calculation rate.



      :Returns:

          BusRate
              the rate of this bus













      ..
          !! processed by numpydoc !!


   .. method:: num_channels(self) -> int
      :property:

      The number of buses.



      :Returns:

          int
              number of buses allocated













      ..
          !! processed by numpydoc !!


   .. method:: idxs(self) -> Sequence[int]
      :property:

      The bus index(s).



      :Returns:

          int
              first bus index













      ..
          !! processed by numpydoc !!


   .. method:: is_audio_bus(self) -> bool

      Rate check



      :Returns:

          bool
              True if this is a audio bus













      ..
          !! processed by numpydoc !!


   .. method:: is_control_bus(self) -> bool

      Rate check



      :Returns:

          bool
              True if this is a control bus













      ..
          !! processed by numpydoc !!


   .. method:: set(self, *values: Sequence[Union[int, float]]) -> None

      Set ranges of bus values.


      :Parameters:

          **values** : sequence of int or float
              Values that should be set





      :Raises:

          RuntimeError
              If trying to setn an Audio Bus









      ..
          !! processed by numpydoc !!


   .. method:: fill(self, value: Union[(int, float)]) -> None

      Fill bus(es) to one value.


      :Parameters:

          **value** : Union[int, float]
              value for the buses





      :Raises:

          RuntimeError
              If fill is used on a Audio Bus









      ..
          !! processed by numpydoc !!


   .. method:: get(self) -> Union[(Union[int, float], Sequence[Union[int, float]])]

      Get bus value(s).



      :Returns:

          bus value or sequence of bus values
              The current value of this bus
              Multiple values if this bus has num_channels > 1




      :Raises:

          RuntimeError
              If get is used on an Audio Bus









      ..
          !! processed by numpydoc !!


   .. method:: free(self, clear: bool = True) -> None

      Mark this Buses ids as free again


      :Parameters:

          **clear** : bool, optional
              Reset bus value(s) to 0, by default True














      ..
          !! processed by numpydoc !!


   .. method:: __del__(self) -> None


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!





.. class:: Recorder(path: Optional[str] = 'record.wav', nr_channels: Optional[int] = 2, rec_header='wav', rec_format='int16', bufsize: Optional[int] = 65536, server: Optional[SCServer] = None)


   Allows to record audio easily.
















   ..
       !! processed by numpydoc !!

   Create and prepare a recorder.


   :Parameters:

       **path** : str, optional
           path of recording file, by default "record.wav"

       **nr_channels** : int, optional
           Number of channels, by default 2

       **rec_header** : str, optional
           File format, by default "wav"

       **rec_format** : str, optional
           Recording resolution, by default "int16"

       **bufsize** : int, optional
           size of buffer, by default 65536

       **server** : SCServer, optional
           server used for recording, by default None
           if None it will use sc3nb.SC.get_default().server














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Recorder.prepare
         sc3nb.Recorder.start
         sc3nb.Recorder.pause
         sc3nb.Recorder.resume
         sc3nb.Recorder.stop
         sc3nb.Recorder.__repr__
         sc3nb.Recorder.__del__

   .. method:: prepare(self, path, nr_channels, rec_header, rec_format, bufsize)

      Pepare the recorder.


      :Parameters:

          **path** : str, optional
              path of recording file, by default "record.wav"

          **nr_channels** : int, optional
              Number of channels, by default 2

          **rec_header** : str, optional
              File format, by default "wav"

          **rec_format** : str, optional
              Recording resolution, by default "int16"

          **bufsize** : int, optional
              size of buffer, by default 65536





      :Raises:

          RuntimeError
              When Recorder does not needs to be prepared.









      ..
          !! processed by numpydoc !!


   .. method:: start(self, timestamp: Optional[float] = 0, duration: Optional[float] = None, node: Union[(Node, int)] = 0, bus: Optional[int] = 0)

      Start the recording.


      :Parameters:

          **timestamp** : Optional[float], optional
              Time (or time offset when <1e6) to start, by default 0

          **duration** : Optional[float], optional
              Length of the recording, by default until stopped.

          **node** : Union[Node, int], optional
              Node that should be recorded, by default 0

          **bus** : Optional[int], optional
              Bus that should be recorded, by default 0





      :Raises:

          RuntimeError
              When trying to start a recording unprepared.









      ..
          !! processed by numpydoc !!


   .. method:: pause(self, timestamp: Optional[float] = 0)

      Pause the recording.


      :Parameters:

          **timestamp** : Optional[float], optional
              Time (or time offset when <1e6) to pause, by default 0





      :Raises:

          RuntimeError
              When trying to pause if not recording.









      ..
          !! processed by numpydoc !!


   .. method:: resume(self, timestamp: Optional[float] = 0)

      Resume the recording


      :Parameters:

          **timestamp** : Optional[float], optional
              Time (or time offset when <1e6) to resume, by default 0





      :Raises:

          RuntimeError
              When trying to resume if not paused.









      ..
          !! processed by numpydoc !!


   .. method:: stop(self, timestamp: Optional[float] = 0)

      Stop the recording.


      :Parameters:

          **timestamp** : Optional[float], optional
              Time (or time offset when <1e6) to stop, by default 0





      :Raises:

          RuntimeError
              When trying to stop if not started.









      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!


   .. method:: __del__(self)





.. class:: TimedQueue(relative_time: bool = False, thread_sleep_time: float = 0.001, drop_time_threshold: float = 0.5)


   Accumulates events as timestamps and functions.

   Executes given functions according to the timestamps

   :Parameters:

       **relative_time** : bool, optional
           If True, use relative time, by default False

       **thread_sleep_time** : float, optional
           Sleep time for worker thread, by default 0.001

       **drop_time_threshold** : float, optional
           Threshold for execution time of events.
           If this is exceeded the event will be dropped, by default 0.5














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.TimedQueue.close
         sc3nb.TimedQueue.join
         sc3nb.TimedQueue.complete
         sc3nb.TimedQueue.put
         sc3nb.TimedQueue.get
         sc3nb.TimedQueue.peek
         sc3nb.TimedQueue.empty
         sc3nb.TimedQueue.pop
         sc3nb.TimedQueue.__worker
         sc3nb.TimedQueue.__repr__
         sc3nb.TimedQueue.elapse

   .. method:: close(self) -> None

      Closes event processing without waiting for pending events
















      ..
          !! processed by numpydoc !!


   .. method:: join(self) -> None

      Closes event processing after waiting for pending events
















      ..
          !! processed by numpydoc !!


   .. method:: complete(self) -> None

      Blocks until all pending events have completed
















      ..
          !! processed by numpydoc !!


   .. method:: put(self, timetag: int, function: Callable[(..., None)], args: Iterable[Any] = (), spawn: bool = False) -> None

      Adds event to queue


      :Parameters:

          **timetag** : int
              Time when event should be executed

          **function** : Callable[..., None]
              Function to be executed

          **args** : Iterable[Any], optional
              Arguments to be passed to function, by default ()

          **spawn** : bool, optional
              if True, create new sub-thread for function, by default False





      :Raises:

          TypeError
              raised if function is not callable









      ..
          !! processed by numpydoc !!


   .. method:: get(self) -> sc3nb.timed_queue.Event

      Get latest event from queue and remove event



      :Returns:

          Event
              Latest event













      ..
          !! processed by numpydoc !!


   .. method:: peek(self) -> sc3nb.timed_queue.Event

      Look up latest event from queue



      :Returns:

          Event
              Latest event













      ..
          !! processed by numpydoc !!


   .. method:: empty(self) -> bool

      Checks if queue is empty



      :Returns:

          bool
              True if queue if empty













      ..
          !! processed by numpydoc !!


   .. method:: pop(self) -> None

      Removes latest event from queue
















      ..
          !! processed by numpydoc !!


   .. method:: __worker(self, sleep_time: float, close_event: threading.Event) -> NoReturn

      Worker function to process events
















      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self)

      Return repr(self).
















      ..
          !! processed by numpydoc !!


   .. method:: elapse(self, time_delta: float) -> None

      Add time delta to the current queue time.


      :Parameters:

          **time_delta** : float
              Additional time














      ..
          !! processed by numpydoc !!





.. class:: TimedQueueSC(server: sc3nb.osc.osc_communication.OSCCommunication = None, relative_time: bool = False, thread_sleep_time: float = 0.001)


   **Bases:** :class:`sc3nb.timed_queue.TimedQueue`

   Timed queue with OSC communication.


   :Parameters:

       **server** : OSCCommunication, optional
           OSC server to handle the bundlers and messsages, by default None

       **relative_time** : bool, optional
           If True, use relative time, by default False

       **thread_sleep_time** : float, optional
           Sleep time for worker thread, by default 0.001














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.TimedQueueSC.put_bundler
         sc3nb.TimedQueueSC.put_msg

   .. method:: put_bundler(self, onset: int, bundler: sc3nb.osc.osc_communication.Bundler) -> None

      Add a Bundler to queue


      :Parameters:

          **onset** : int
              Sending timetag of the Bundler

          **bundler** : Bundler
              Bundler that will be send














      ..
          !! processed by numpydoc !!


   .. method:: put_msg(self, onset: int, msg: Union[(OscMessage, str)], args: Iterable[Any]) -> None

      Add a message to queue


      :Parameters:

          **onset** : int
              Sending timetag of the message

          **msg** : Union[OscMessage, str]
              OscMessage or OSC address

          **args** : Iterable[Any]
              If msg is str, this will be the arguments of the created OscMessage














      ..
          !! processed by numpydoc !!





.. function:: build_message(msg_addr: str, msg_args: Optional[Union[Sequence, Any]] = None) -> pythonosc.osc_message.OscMessage

   Builds pythonsosc OSC message.


   :Parameters:

       **msg_addr** : str
           SuperCollider address.

       **msg_args** : None or list or dict
           List of arguments to add to message.

   :Returns:

       OscMessage
           Message ready to be sent.













   ..
       !! processed by numpydoc !!


.. class:: Bundler(timestamp: float = 0, msg: Optional[Union[OscMessage, str]] = None, msg_args: Optional[Sequence[Any]] = None, server: Optional['OSCCommunication'] = None, receiver: Optional[Union[str, Tuple[str, int]]] = None, send_on_exit: bool = True)


   Class for creating OSCBundles and Bundling of Messages
















   ..
       !! processed by numpydoc !!

   Create a Bundler


   :Parameters:

       **timestamp** : float, optional
           Starting time at which bundle content should be executed.
           If timestamp <= 1e6 it is added to time.time(), by default 0

       **msg** : OscMessage or str, optional
           OscMessage or message address, by default None

       **msg_args** : sequence of any type, optional
           Arguments for the message, by default None

       **server** : OSCCommunication, optional
           OSC server, by default None

       **receiver** : Union[str, Tuple[str, int]], optional
           Where to send the bundle, by default send to default receiver of server

       **send_on_exit** : bool, optional
           Wether the bundle is send when using as context manger, by default True














   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.Bundler.wait
         sc3nb.Bundler.add
         sc3nb.Bundler.__deepcopy__
         sc3nb.Bundler.build
         sc3nb.Bundler.send
         sc3nb.Bundler.__enter__
         sc3nb.Bundler.__exit__

   .. method:: wait(self, time_passed: float) -> None

      Add time to internal time


      :Parameters:

          **time_passed** : float
              How much secounds should be passed.














      ..
          !! processed by numpydoc !!


   .. method:: add(self, *params) -> sc3nb.osc.osc_communication.Bundler

      Add a pythonosc OscMessage or OscBundle to this bundle.


      :Parameters:

          **params** : OscMessage or Bundler or Bundler arguments like
              (timestamp, msg_addr, msg_args)
              (timestamp, msg_addr)
              (timestamp, msg)

      :Returns:

          Bundler
              self for chaining













      ..
          !! processed by numpydoc !!


   .. method:: __deepcopy__(self, memo) -> sc3nb.osc.osc_communication.Bundler


   .. method:: build(self, time_offset: Optional[float] = None) -> pythonosc.osc_bundle.OscBundle

      Build this bundle.


      :Parameters:

          **time_offset** : Optional[float], optional
              used for recursion, by default None

      :Returns:

          OscBundle
              bundle instance for sending













      ..
          !! processed by numpydoc !!


   .. method:: send(self, server: Optional['OSCCommunication'] = None, receiver: Tuple[(str, int)] = None, bundled: bool = True)

      Send this Bundler.


      :Parameters:

          **server** : OSCCommunication, optional
              Server instance for sending the bundle.
              If None it will use the server from init
              or try to use sc3nb.SC.get_default().server, by default None

          **receiver** : Tuple[str, int], optional
              Address (ip, port) to send to, if None it will send the bundle to
              the default receiver of the Bundler

          **bundled** : bool, optional
              If True this is allowed to be bundled, by default True





      :Raises:

          RuntimeError
              When no server could be found.









      ..
          !! processed by numpydoc !!


   .. method:: __enter__(self)


   .. method:: __exit__(self, exc_type, exc_value, exc_traceback)





.. function:: linlin(value: Union[(float, np.ndarray)], x1: float, x2: float, y1: float, y2: float) -> Union[(float, np.ndarray)]

   Map value linearly so that [x1, x2] is mapped to [y1, y2]

   linlin is implemented in analogy to the SC3 linlin, yet this
   function extrapolates by default.
   A frequently used invocation is with x1 < x2, i.e. thinking
   of them as a range [x1,x2]

   :Parameters:

       **value** : float or np.ndarray
           value(s) to be mapped

       **x1** : float
           source value 1

       **x2** : float
           source value 2

       **y1** : float
           destination value to be reached for value == x1

       **y2** : float
           destination value to be reached for value == x2

   :Returns:

       float
           the mapping result













   ..
       !! processed by numpydoc !!


.. function:: midicps(midi_note: float) -> float

   Convert MIDI note to cycles per second


   :Parameters:

       **m** : float
           midi note

   :Returns:

       float
           corresponding cycles per seconds













   ..
       !! processed by numpydoc !!


.. function:: cpsmidi(cps: float) -> float

   Convert cycles per second to MIDI note


   :Parameters:

       **cps** : float
           cycles per second

   :Returns:

       float
           corresponding MIDI note













   ..
       !! processed by numpydoc !!


.. function:: clip(value: float, minimum: float = -float('inf'), maximum: float = float('inf')) -> float

   Clips a value to a certain range


   :Parameters:

       **value** : float
           Value to clip

       **minimum** : float, optional
           Minimum output value, by default -float("inf")

       **maximum** : float, optional
           Maximum output value, by default float("inf")

   :Returns:

       float
           clipped value













   ..
       !! processed by numpydoc !!


.. function:: dbamp(decibels: float) -> float

   Convert a decibels to a linear amplitude.


   :Parameters:

       **decibels** : float
           Decibel value to convert

   :Returns:

       float
           Corresponding linear amplitude













   ..
       !! processed by numpydoc !!


.. function:: ampdb(amp: float) -> float

   Convert a linear amplitude to decibels.


   :Parameters:

       **amp** : float
           Linear amplitude to convert

   :Returns:

       float
           Corresponding decibels













   ..
       !! processed by numpydoc !!




Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 2

   osc/index.rst
   resources/index.rst
   sc_objects/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   helpers/index.rst
   magics/index.rst
   process_handling/index.rst
   sc/index.rst
   sclang/index.rst
   timed_queue/index.rst


