:mod:`sc3nb.sc_objects.buffer`
==============================

.. py:module:: sc3nb.sc_objects.buffer

.. autoapi-nested-parse::

   Module for using SuperCollider Buffers in Python

   ..
       !! processed by numpydoc !!



Module Contents
---------------

 



Class List
~~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   sc3nb.sc_objects.buffer.BufferReply
   sc3nb.sc_objects.buffer.BufferCommand
   sc3nb.sc_objects.buffer.BufferAllocationMode
   sc3nb.sc_objects.buffer.BufferInfo
   sc3nb.sc_objects.buffer.Buffer



Content
~~~~~~~

.. class:: BufferReply


   **Bases:** :class:`str`, :class:`enum.Enum`

   Buffer Command Replies
















   ..
       !! processed by numpydoc !!

   Initialize self.  See help(type(self)) for accurate signature.
















   ..
       !! processed by numpydoc !!



   .. attribute:: INFO
      :annotation: = /b_info

      






.. class:: BufferCommand


   **Bases:** :class:`str`, :class:`enum.Enum`

   Buffer OSC Commands for Buffers
















   ..
       !! processed by numpydoc !!

   Initialize self.  See help(type(self)) for accurate signature.
















   ..
       !! processed by numpydoc !!



   .. attribute:: ALLOC
      :annotation: = /b_alloc

      

   .. attribute:: ALLOC_READ
      :annotation: = /b_allocRead

      

   .. attribute:: ALLOC_READ_CHANNEL
      :annotation: = /b_allocReadChannel

      

   .. attribute:: READ
      :annotation: = /b_read

      

   .. attribute:: READ_CHANNEL
      :annotation: = /b_readChannel

      

   .. attribute:: WRITE
      :annotation: = /b_write

      

   .. attribute:: FREE
      :annotation: = /b_free

      

   .. attribute:: ZERO
      :annotation: = /b_zero

      

   .. attribute:: SET
      :annotation: = /b_set

      

   .. attribute:: SETN
      :annotation: = /b_setn

      

   .. attribute:: FILL
      :annotation: = /b_fill

      

   .. attribute:: GEN
      :annotation: = /b_gen

      

   .. attribute:: CLOSE
      :annotation: = /b_close

      

   .. attribute:: QUERY
      :annotation: = /b_query

      

   .. attribute:: GET
      :annotation: = /b_get

      

   .. attribute:: GETN
      :annotation: = /b_getn

      






.. class:: BufferAllocationMode


   **Bases:** :class:`str`, :class:`enum.Enum`

   Buffer Allocation Modes
















   ..
       !! processed by numpydoc !!

   Initialize self.  See help(type(self)) for accurate signature.
















   ..
       !! processed by numpydoc !!



   .. attribute:: FILE
      :annotation: = file

      

   .. attribute:: ALLOC
      :annotation: = alloc

      

   .. attribute:: DATA
      :annotation: = data

      

   .. attribute:: EXISTING
      :annotation: = existing

      

   .. attribute:: COPY
      :annotation: = copy

      

   .. attribute:: NONE
      :annotation: = none

      






.. class:: BufferInfo

   **Bases:** :class:`typing.NamedTuple`

   Information about the Buffer
















   ..
       !! processed by numpydoc !!



   .. attribute:: bufnum
      :annotation: :int

      

   .. attribute:: num_frames
      :annotation: :int

      

   .. attribute:: num_channels
      :annotation: :int

      

   .. attribute:: sample_rate
      :annotation: :float

      






.. class:: Buffer(bufnum: Optional[int] = None, server: Optional['SCServer'] = None)


   A Buffer object represents a SuperCollider3 Buffer on scsynth
   and provides access to low-level buffer commands of scsynth via
   methods of the Buffer objects.

   The constructor merely initializes a buffer:

   * it selects a buffer number using the server's buffer allocator
   * it initializes attribute variables

   :Parameters:

       **bufnum** : int
           buffer number to be used on scsynth. Defaults to None,
           can be set to enforce a given bufnum

       **server** : SCServer, optional
           The server instance to establish the Buffer









   .. rubric:: Notes

   For more information on Buffer commands, refer to the Server Command Reference in SC3.
   https://doc.sccode.org/Reference/Server-Command-Reference.html#Buffer%20Commands


   .. rubric:: Examples

   (see examples/buffer-examples.ipynb)

   >>> b = Buffer().load_file(...)
   >>> b = Buffer().load_data(...)
   >>> b = Buffer().alloc(...)
   >>> b = Buffer().load_asig(...)
   >>> b = Buffer().use_existing(...)
   >>> b = Buffer().copy(Buffer)

   :Attributes:

       **server** : the SCServer object
           to communicate with scsynth

       **_bufnum** : int
           buffer number = bufnum id on scsynth

       **_sr** : int
           the sampling rate of the buffer

       **_channels** : int
           number of channels of the buffer

       **_samples** : int
           buffer length = number of sample frames

       **_alloc_mode** : str
           ['file', 'alloc', 'data', 'existing', 'copy']
           according to previously used generator, defaults to None

       **_allocated** : boolean
           True if Buffer has been allocated by
           any of the initialization methods

       **_path** : str
           path to the audio file used in load_file()


   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.sc_objects.buffer.Buffer.read
         sc3nb.sc_objects.buffer.Buffer.alloc
         sc3nb.sc_objects.buffer.Buffer.load_data
         sc3nb.sc_objects.buffer.Buffer.load_collection
         sc3nb.sc_objects.buffer.Buffer.load_asig
         sc3nb.sc_objects.buffer.Buffer.use_existing
         sc3nb.sc_objects.buffer.Buffer.copy_existing
         sc3nb.sc_objects.buffer.Buffer.fill
         sc3nb.sc_objects.buffer.Buffer.gen
         sc3nb.sc_objects.buffer.Buffer.zero
         sc3nb.sc_objects.buffer.Buffer.gen_sine1
         sc3nb.sc_objects.buffer.Buffer.gen_sine2
         sc3nb.sc_objects.buffer.Buffer.gen_sine3
         sc3nb.sc_objects.buffer.Buffer.gen_cheby
         sc3nb.sc_objects.buffer.Buffer.gen_copy
         sc3nb.sc_objects.buffer.Buffer.play
         sc3nb.sc_objects.buffer.Buffer.write
         sc3nb.sc_objects.buffer.Buffer.close
         sc3nb.sc_objects.buffer.Buffer.to_array
         sc3nb.sc_objects.buffer.Buffer.query
         sc3nb.sc_objects.buffer.Buffer.__repr__
         sc3nb.sc_objects.buffer.Buffer.free
         sc3nb.sc_objects.buffer.Buffer.bufnum
         sc3nb.sc_objects.buffer.Buffer.allocated
         sc3nb.sc_objects.buffer.Buffer.alloc_mode
         sc3nb.sc_objects.buffer.Buffer.path
         sc3nb.sc_objects.buffer.Buffer.channels
         sc3nb.sc_objects.buffer.Buffer.samples
         sc3nb.sc_objects.buffer.Buffer.sr
         sc3nb.sc_objects.buffer.Buffer.duration
         sc3nb.sc_objects.buffer.Buffer.server
         sc3nb.sc_objects.buffer.Buffer._gen_flags

   .. method:: read(self, path: str, starting_frame: int = 0, num_frames: int = -1, channels: Optional[Union[int, Sequence[int]]] = None) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer memory and read a sound file.

      If the number of frames argument num_frames is negative or zero,
      the entire file is read.

      :Parameters:

          **path** : string
              path name of a sound file.

          **starting_frame** : int
              starting frame in file

          **num_frames** : int
              number of frames to read

          **channels** : list | int
              channels and order of channels to be read from file.
              if only a int is provided it is loaded as only channel

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: alloc(self, size: int, sr: int = 44100, channels: int = 1) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer memory.


      :Parameters:

          **size** : int
              number of frames

          **sr** : int
              sampling rate in Hz (optional. default = 44100)

          **channels** : int
              number of channels (optional. default = 1 channel)

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: load_data(self, data: numpy.ndarray, sr: int = 44100, mode: str = 'file', sync: bool = True) -> sc3nb.sc_objects.buffer.Buffer

      Allocate buffer memory and read input data.


      :Parameters:

          **data** : numpy array
              Data which should inserted

          **sr** : int, default: 44100
              sample rate

          **mode** : 'file' or 'osc'
              Insert data via filemode ('file') or n_set OSC commands ('osc')
              Bundling is only supported for 'osc' mode and if sync is False.

          **sync: bool, default: True**
              Use SCServer.sync after sending messages when mode = 'osc'

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: load_collection(self, data: numpy.ndarray, mode: str = 'file', sr: int = 44100) -> sc3nb.sc_objects.buffer.Buffer

      Wrapper method of :func:`Buffer.load_data`
















      ..
          !! processed by numpydoc !!


   .. method:: load_asig(self, asig: pya.Asig, mode: str = 'file') -> sc3nb.sc_objects.buffer.Buffer

      Create buffer from asig


      :Parameters:

          **asig** : pya.Asig
              asig to be loaded in buffer

          **mode** : str, optional
              Insert data via filemode ('file') or n_set OSC commands ('osc'), by default 'file'

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: use_existing(self, bufnum: int, sr: int = 44100) -> sc3nb.sc_objects.buffer.Buffer

      Creates a buffer object from already existing Buffer bufnum.


      :Parameters:

          **bufnum** : int
              buffer node id

          **sr** : int
              Sample rate

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: copy_existing(self, buffer: sc3nb.sc_objects.buffer.Buffer) -> sc3nb.sc_objects.buffer.Buffer

      Duplicate an existing buffer


      :Parameters:

          **buffer** : Buffer object
              Buffer which should be duplicated

      :Returns:

          **self** : Buffer
              the newly created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is already allocated.









      ..
          !! processed by numpydoc !!


   .. method:: fill(self, start: int = 0, count: int = 0, value: float = 0) -> sc3nb.sc_objects.buffer.Buffer

      Fill range of samples with value(s).


      :Parameters:

          **start** : int or list
              int : sample starting index
              list : n*[start, count, value] list

          **count** : int
              number of samples to fill

          **value** : float
              value

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen(self, command: str, args: List[Any]) -> sc3nb.sc_objects.buffer.Buffer

      Call a command to fill a buffer.
      If you know, what you do -> you can use this method.


      :Parameters:

          **command** : str
              What fill command to use.

          **args** : List[Any]
              Arguments for command

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.



      .. seealso::

          
          :obj:`gen_sine1`, :obj:`gen_sine2`, :obj:`gen_cheby`, :obj:`gen_cheby`, :obj:`gen_copy`
              ..
          





      ..
          !! processed by numpydoc !!


   .. method:: zero(self) -> sc3nb.sc_objects.buffer.Buffer

      Set buffer data to zero.



      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine1(self, amplitudes: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves & given amplitude


      :Parameters:

          **amplitudes** : list
              The first float value specifies the amplitude of the first partial,
              the second float value specifies the amplitude of the second
              partial, and so on.

          **normalize** : bool
              Normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, then the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set then the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine2(self, freq_amps: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves
      given list of [frequency, amplitude] lists


      :Parameters:

          **freq_amps** : list
              Similar to sine1 except that each partial frequency is specified
              explicitly instead of being an integer multiple of the fundamental.
              Non-integer partial frequencies are possible.

          **normalize** : bool
              If set, normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set, the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_sine3(self, freqs_amps_phases: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fill the buffer with sine waves & given a list of
      [frequency, amplitude, phase] entries.


      :Parameters:

          **freqs_amps_phases** : list
              Similar to sine2 except that each partial may have a
              nonzero starting phase.

          **normalize** : bool
              if set, normalize peak amplitude of wave to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format
              so that it can be read by interpolating oscillators.

          **clear** : bool
              If set, the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_cheby(self, amplitudes: List[float], normalize: bool = False, wavetable: bool = False, clear: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Fills a buffer with a series of chebyshev polynomials, which can be
      defined as cheby(n) = amplitude * cos(n * acos(x))


      :Parameters:

          **amplitudes** : list
              The first float value specifies the amplitude for n = 1,
              the second float value specifies the amplitude
              for n = 2, and so on

          **normalize** : bool
              If set, normalize the peak amplitude of the Buffer to 1.0.

          **wavetable** : bool
              If set, the buffer is written in wavetable format so that it
              can be read by interpolating oscillators.

          **clear** : bool
              If set the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: gen_copy(self, source: sc3nb.sc_objects.buffer.Buffer, source_pos: int, dest_pos: int, copy_amount: int) -> sc3nb.sc_objects.buffer.Buffer

      Copy samples from the source buffer to the destination buffer
      specified in the b_gen command.


      :Parameters:

          **source** : Buffer
              Source buffer object

          **source_pos** : int
              sample position in source

          **dest_pos** : int
              sample position in destination

          **copy_amount** : int
              number of samples to copy. If the number of samples to copy is
              negative, the maximum number of samples
              possible is copied.

      :Returns:

          **self** : Buffer
              the created Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: play(self, rate: float = 1, loop: bool = False, pan: float = 0, amp: float = 0.3) -> sc3nb.sc_objects.node.Synth

      Play the Buffer using a Synth


      :Parameters:

          **rate** : float, optional
              plackback rate, by default 1

          **loop** : bool, optional
              if True loop the playback, by default False

          **pan** : int, optional
              pan position, -1 is left, +1 is right, by default 0

          **amp** : float, optional
              amplitude, by default 0.3

      :Returns:

          Synth
              Synth to control playback.




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: write(self, path: str, header: str = 'wav', sample: str = 'float', num_frames: int = -1, starting_frame: int = 0, leave_open: bool = False) -> sc3nb.sc_objects.buffer.Buffer

      Write buffer data to a sound file


      :Parameters:

          **path** : string
              path name of a sound file.

          **header** : string
              header format. Header format is one of:
              "aiff", "next", "wav", "ircam"", "raw"

          **sample** : string
              sample format. Sample format is one of:
              "int8", "int16", "int24", "int32",
              "float", "double", "mulaw", "alaw"

          **num_frames** : int
              number of frames to write.
              -1 means all frames.

          **starting_frame** : int
              starting frame in buffer

          **leave_open** : boolean
              Whether you want the buffer file left open.
              For use with DiskOut you will want this to be true.
              The file is created, but no frames are written until the DiskOut UGen does so.
              The default is false which is the correct value for all other cases.

      :Returns:

          **self** : Buffer
              the Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: close(self) -> sc3nb.sc_objects.buffer.Buffer

      Close soundfile after using a Buffer with DiskOut



      :Returns:

          **self** : Buffer
              the Buffer object




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: to_array(self) -> numpy.ndarray

      Return the buffer data as an array representation.



      :Returns:

          np.ndarray:
              Values of the buffer




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: query(self) -> sc3nb.sc_objects.buffer.BufferInfo

      Get buffer info.



      :Returns:

          Tuple:
              (buffer number, number of frames, number of channels, sampling rate)




      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!


   .. method:: free(self) -> None

      Free buffer data.







      :Raises:

          RuntimeError
              If the Buffer is not allocated yet.









      ..
          !! processed by numpydoc !!


   .. method:: bufnum(self) -> Optional[int]
      :property:

      Buffer number which serves as ID in SuperCollider



      :Returns:

          int
              bufnum













      ..
          !! processed by numpydoc !!


   .. method:: allocated(self) -> bool
      :property:

      Whether this Buffer is allocated by
      any of the initialization methods.



      :Returns:

          bool
              True if allocated













      ..
          !! processed by numpydoc !!


   .. method:: alloc_mode(self) -> sc3nb.sc_objects.buffer.BufferAllocationMode
      :property:

      Mode of Buffer allocation.

      One of ['file', 'alloc', 'data', 'existing', 'copy']
      according to previously used generator.
      Defaults to None if not allocated.


      :Returns:

          str
              allocation mode













      ..
          !! processed by numpydoc !!


   .. method:: path(self) -> Optional[Path]
      :property:

      File path that was provided to read.



      :Returns:

          pathlib.Path
              buffer file path













      ..
          !! processed by numpydoc !!


   .. method:: channels(self) -> Optional[int]
      :property:

      Number of channels in the Buffer.



      :Returns:

          int
              channel number













      ..
          !! processed by numpydoc !!


   .. method:: samples(self) -> Optional[int]
      :property:

      Number of samples in the buffer.



      :Returns:

          int
              sample number













      ..
          !! processed by numpydoc !!


   .. method:: sr(self) -> Optional[int]
      :property:

      Sampling rate of the Buffer.



      :Returns:

          int
              sampling rate













      ..
          !! processed by numpydoc !!


   .. method:: duration(self) -> Optional[float]
      :property:

      Duration of the Buffer in seconds.



      :Returns:

          float
              duration in seconds













      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> sc3nb.sc_objects.server.SCServer
      :property:

      The server where this Buffer is placed.



      :Returns:

          SCServer
              The server where this Buffer is placed.













      ..
          !! processed by numpydoc !!


   .. method:: _gen_flags(self, a_normalize=False, a_wavetable=False, a_clear=False) -> int

      Generate Wave Fill Commands flags from booleans
      according to the SuperCollider Server Command Reference.


      :Parameters:

          **a_normalize** : bool, optional
              Normalize peak amplitude of wave to 1.0, by default False

          **a_wavetable** : bool, optional
              If set, then the buffer is written in wavetable
              format so that it can be read by interpolating
              oscillators, by default False

          **a_clear** : bool, optional
              If set then the buffer is cleared before new partials are written
              into it. Otherwise the new partials are summed with the existing
              contents of the buffer, by default False

      :Returns:

          int
              Wave Fill Commands flags













      ..
          !! processed by numpydoc !!







