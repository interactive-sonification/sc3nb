:mod:`sc3nb.sclang`
===================

.. py:module:: sc3nb.sclang

.. autoapi-nested-parse::

   Module for handling a SuperCollider language (sclang) process.

   ..
       !! processed by numpydoc !!



Module Contents
---------------

 

Function List
~~~~~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   sc3nb.sclang.remove_comments
   sc3nb.sclang.parse_pyvars
   sc3nb.sclang.replace_vars
   sc3nb.sclang.convert_to_sc




Class List
~~~~~~~~~~

.. autoapisummary::
   :nosignatures:

   sc3nb.sclang.SynthArgument
   sc3nb.sclang.SCLang



Content
~~~~~~~

.. data:: _LOGGER
   

   

.. data:: SCLANG_DEFAULT_PORT
   :annotation: = 57120

   

.. data:: SC3NB_SCLANG_CLIENT_ID
   :annotation: = 0

   

.. class:: SynthArgument

   **Bases:** :class:`typing.NamedTuple`

   Synth Argument rate and default value
















   ..
       !! processed by numpydoc !!



   .. attribute:: name
      :annotation: :str

      

   .. attribute:: rate
      :annotation: :str

      

   .. attribute:: default
      :annotation: :Any

      






.. function:: remove_comments(code: str) -> str

   Removes all c-style comments from code.

   This removes `//single-line` or `/* multi-line */`  comments.

   :Parameters:

       **code** : str
           Code where comments should be removed.

   :Returns:

       str
           code string without comments













   ..
       !! processed by numpydoc !!


.. function:: parse_pyvars(code: str, frame_nr: int = 2)

   Looks through call stack and finds values of variables.


   :Parameters:

       **code** : str
           SuperCollider command to be parsed

       **frame_nr** : int, optional
           on which frame to start, by default 2 (grandparent frame)

   :Returns:

       dict
           {variable_name: variable_value}




   :Raises:

       NameError
           If the variable value could not be found.









   ..
       !! processed by numpydoc !!


.. function:: replace_vars(code: str, pyvars: dict) -> str

   Replaces python variables with SuperCollider literals in code.

   This replaces the pyvars preceded with ^ in the code with a SC literal.
   The conversion is done with convert_to_sc.

   :Parameters:

       **code** : str
           SuperCollider Code with python injections.

       **pyvars** : dict
           Dict with variable names and values.

   :Returns:

       str
           Code with injected variables.













   ..
       !! processed by numpydoc !!


.. function:: convert_to_sc(obj: Any) -> str

   Converts python objects to SuperCollider code literals.

   This supports currently:

   * numpy.ndarray -> SC Array representation
   * complex type -> SC Complex
   * strings -> if starting with sc3: it will be used as SC code
                if it starts with a \ (single escaped backward slash) it will be used as symbol
                else it will be inserted as string

   For unsupported types the __repr__ will be used.

   :Parameters:

       **obj** : Any
           object that should be converted to a SuperCollider code literal.

   :Returns:

       str
           SuperCollider Code literal













   ..
       !! processed by numpydoc !!


.. exception:: SCLangError(message, sclang_output=None)


   **Bases:** :class:`Exception`

   Exception for Errors related to SuperColliders sclang.
















   ..
       !! processed by numpydoc !!

   Initialize self.  See help(type(self)) for accurate signature.
















   ..
       !! processed by numpydoc !!








.. class:: SCLang


   Class to control the SuperCollider Language Interpreter (sclang).
















   ..
       !! processed by numpydoc !!

   Creates a python representation of sclang.







   :Raises:

       NotImplementedError
           When an unsupported OS was found.









   ..
       !! processed by numpydoc !!





   **Overview:**

   .. autoapisummary::
      :nosignatures:

         sc3nb.sclang.SCLang.start
         sc3nb.sclang.SCLang._init
         sc3nb.sclang.SCLang.load_synthdefs
         sc3nb.sclang.SCLang.kill
         sc3nb.sclang.SCLang.__del__
         sc3nb.sclang.SCLang.__repr__
         sc3nb.sclang.SCLang.cmd
         sc3nb.sclang.SCLang.cmdv
         sc3nb.sclang.SCLang.cmds
         sc3nb.sclang.SCLang.cmdg
         sc3nb.sclang.SCLang.read
         sc3nb.sclang.SCLang.empty
         sc3nb.sclang.SCLang.get_synth_desc
         sc3nb.sclang.SCLang.addr
         sc3nb.sclang.SCLang.server
         sc3nb.sclang.SCLang.connect_to_server

   .. method:: start(self, sclang_path: Optional[str] = None, console_logging: bool = True, allowed_parents: Sequence[str] = ALLOWED_PARENTS, timeout: float = 5) -> None

      Start and initilize the sclang process.

      This will also kill sclang processes that does not have allowed parents.

      :Parameters:

          **sclang_path** : Optional[str], optional
              Path with the sclang executable, by default None

          **console_logging** : bool, optional
              If True log sclang output to console, by default True

          **allowed_parents** : Sequence[str], optional
              parents name of processes to keep, by default ALLOWED_PARENTS

          **timeout** : float, optional
              timeout for starting the executable, by default 5





      :Raises:

          SCLangError
              When starting or initilizing sclang failed.









      ..
          !! processed by numpydoc !!


   .. method:: _init(self)


   .. method:: load_synthdefs(self, synthdefs_path: Optional[str] = None) -> None

      Load SynthDef files from path.


      :Parameters:

          **synthdefs_path** : str, optional
              Path where the SynthDef files are located.
              If no path provided, load default sc3nb SynthDefs.














      ..
          !! processed by numpydoc !!


   .. method:: kill(self) -> int

      Kill this sclang instance.



      :Returns:

          int
              returncode of the process.













      ..
          !! processed by numpydoc !!


   .. method:: __del__(self)


   .. method:: __repr__(self) -> str

      Return repr(self).
















      ..
          !! processed by numpydoc !!


   .. method:: cmd(self, code: str, pyvars: Optional[dict] = None, verbose: bool = True, discard_output: bool = True, get_result: bool = False, print_error: bool = True, get_output: bool = False, timeout: int = 1) -> Any

      Send code to sclang to execute it.

      This also allows to get the result of the code or the corresponding output.

      :Parameters:

          **code** : str
              SuperCollider code to execute.

          **pyvars** : dict, optional
              Dictionary of name and value pairs of python
              variables that can be injected via ^name, by default None

          **verbose** : bool, optional
              If True print output, by default True

          **discard_output** : bool, optional
              If True clear output buffer before passing command, by default True

          **get_result** : bool, optional
              If True receive and return the
              evaluation result from sclang, by default False

          **print_error** : bool, optional
              If this and get_result is True and code execution fails
              the output from sclang will be printed.

          **get_output** : bool, optional
              If True return output. Does not override get_result
              If verbose this will be True, by default False

          **timeout** : int, optional
              Timeout for code execution return result, by default 1

      :Returns:

          Any
              if get_result=True,
                  Result from SuperCollider code,
                  not all SC types supported.
                  When type is not understood this
                  will return the datagram from the
                  OSC packet.
              if get_output or verbose
                  Output from SuperCollider code.
              else
                  None




      :Raises:

          RuntimeError
              If get_result is True but no OSCCommunication instance is set.

          SCLangError
              When an error with sclang occurs.









      ..
          !! processed by numpydoc !!


   .. method:: cmdv(self, code: str, **kwargs) -> Any

      cmd with verbose=True
















      ..
          !! processed by numpydoc !!


   .. method:: cmds(self, code: str, **kwargs) -> Any

      cmd with verbose=False, i.e. silent
















      ..
          !! processed by numpydoc !!


   .. method:: cmdg(self, code: str, **kwargs) -> Any

      cmd with get_result=True
















      ..
          !! processed by numpydoc !!


   .. method:: read(self, expect: Optional[str] = None, timeout: float = 1, print_error: bool = True) -> str

      Reads SuperCollider output from the process output queue.


      :Parameters:

          **expect** : Optional[str], optional
              Try to read this expected string, by default None

          **timeout** : float, optional
              How long we try to read expected string, by default 1

          **print_error** : bool, optional
              If True this will print a message when timed out, by default True

      :Returns:

          str
              output from sclang process.




      :Raises:

          timeout
              If expected output string could not be read before timeout.









      ..
          !! processed by numpydoc !!


   .. method:: empty(self) -> None

      Empties sc output queue.
















      ..
          !! processed by numpydoc !!


   .. method:: get_synth_desc(self, synth_def)

      Get SynthDesc via sclangs global SynthDescLib.


      :Parameters:

          **synth_def** : str
              SynthDef name

      :Returns:

          dict
              {argument_name: SynthArgument(rate, default)}




      :Raises:

          ValueError
              When synthDesc of synthDef can not be found.









      ..
          !! processed by numpydoc !!


   .. method:: addr(self) -> Tuple[(str, int)]
      :property:

      The address of this sclang
















      ..
          !! processed by numpydoc !!


   .. method:: server(self) -> Optional[SCServer]
      :property:

      The SuperCollider server connected to this sclang instance.
















      ..
          !! processed by numpydoc !!


   .. method:: connect_to_server(self, server: Optional[SCServer] = None)

      Connect this sclang instance to the SuperCollider Server.

      This will set Server.default and s to a the provided remote Server.

      :Parameters:

          **server** : Optional[SCServer], optional
              SuperCollider Server to connect. If None try to reconnect.





      :Raises:

          ValueError
              If something different from a SCServer or None was provided

          SCLangError
              If sclang failed to register to the server.









      ..
          !! processed by numpydoc !!







